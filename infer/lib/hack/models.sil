// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

.source_language = "hack"

// These functions have OCaml models
declare $builtins.nondet() : int

type HackDict extends HH::AnyArray = .final {}

type HackInt = .final { val: int }

define $builtins.hack_int(i: int): *HackInt {
  #entry:
    n0 = __sil_allocate(<HackInt>)
    n1: int = load &i
    store n0.HackInt.val <- n1 : int
    ret n0
}

type HackFloat = .final { val: float }

define $builtins.hack_float(f: float): *HackFloat {
  #entry:
    n0 = __sil_allocate(<HackFloat>)
    n1: float = load &f
    store n0.HackFloat.val <- n1 : float
    ret n0
}

type HackBool = .final { val: int }

define $builtins.hack_bool(b: int): *HackBool {
  #entry:
    n0 = __sil_allocate(<HackBool>)
    n1: int = load &b
    store n0.HackBool.val <- n1 : int
    ret n0
}

define $builtins.hack_make_true(): *HackBool {
  #entry:
    ret $builtins.hack_bool(1)
}

define $builtins.hack_make_false(): *HackBool {
  #entry:
    ret $builtins.hack_bool(0)
}

define $builtins.hack_make_random_bool(): *HackBool {
  #entry:
    ret $builtins.hack_bool($builtins.nondet())
}

define $builtins.hhbc_class_has_reified_generics(class: *HackMixed): *HackMixed {
  #entry:
    ret $builtins.hack_make_false()
}

define $builtins.hhbc_has_reified_parent(class: *HackMixed): *HackMixed {
  #entry:
    ret $builtins.hack_make_false()
}

define $builtins.hhbc_is_type_null(o: *HackMixed): *HackMixed {
  #entry:
    jmp tlab, flab

  #tlab:
    n0: *HackMixed = load &o
    prune __sil_ne(n0, 0)
    ret $builtins.hack_make_false()

  #flab:
    n0: *HackMixed = load &o
    prune __sil_lnot(__sil_ne(n0, 0))
    ret $builtins.hack_make_true()
}

define $builtins.hhbc_is_late_bound_cls(o: *HackMixed): *HackMixed {
  #entry:
    ret $builtins.hack_make_random_bool()
}

define $builtins.hhbc_lock_obj(o: *HackMixed): *HackMixed {
  #entry:
    ret null
}

define $builtins.hhbc_check_this(o: *HackMixed): *HackMixed {
  #entry:
    ret null
}

type HackVec extends HH::AnyArray = .final {
  __infer_model_backing_vec_fst: *HackMixed;
  __infer_model_backing_vec_snd: *HackMixed;
  __infer_model_backing_vec_size: int;
  __infer_model_backing_last_read: int
}

type HH::int equals HackInt
type HH::vec equals HackVec

declare $builtins.hhbc_new_vec(...): *HackMixed
declare $builtins.hhbc_await(*HackMixed): *HackMixed

// This actually only works for vecs at the moment
// new fst is old second
// new snd is appended value
// size is incremented
// old fst is fake awaited
define $builtins.hack_array_cow_append(v: *HackVec, o: *HackMixed): *HackMixed {
  #entry:
    n0: *HackMixed = load &v
    n1: *HackMixed = load n0.HackVec.__infer_model_backing_vec_fst
    n2: *HackMixed = load n0.HackVec.__infer_model_backing_vec_snd
    n3 = $builtins.hhbc_await(n1)
    n4: *HackMixed = load &o
    n5 = $builtins.hhbc_new_vec(n2, n4)
    n6: int = load n0.HackVec.__infer_model_backing_vec_size
    store n5.HackVec.__infer_model_backing_vec_size <- __sil_plusa_int(n6,1) : int
    ret n5
}

define HackMixed._86reifiedinit(o: *HackMixed): *HackMixed {
  #entry:
    ret null
}

// type declarations below here were generated by scripts/hhidecls.ml
// manually pasting for now as they may need some manual editing
// but we should eventually automate their generation and inclusion

// decls from ./BuiltinEnum.hhi
type HH::BuiltinAbstractEnumClass = .kind="class" .abstract {}
type HH::BuiltinEnum = .kind="class" .abstract {}
type HH::BuiltinEnumClass extends HH::BuiltinAbstractEnumClass  = .kind="class" .abstract {}
// ALIAS: type HH::MemberOf should be defined manually above
// ALIAS: type HH::enumname should be defined manually above
// decls from ./InvalidOperationException.hhi
type InvalidOperationException extends RuntimeException, StringishObject  = .kind="class" {}
// decls from ./Label.hhi
// ALIAS: type HH::EnumClass::Label should be defined manually above
// decls from ./NumberFormatter.hhi
type NumberFormatter = .kind="class" {}
// decls from ./Shapes.hhi
type HH::Shapes = .kind="class" .abstract .final {}
// decls from ./XMLReader.hhi
type XMLReader = .kind="class" {}
// decls from ./attributes.hhi
type HH::ClassAttribute extends HH::ClassLikeAttribute  = .kind="interface" {}
type HH::ClassConstantAttribute = .kind="interface" {}
type HH::ClassLikeAttribute = .kind="interface" {}
type HH::EnumAttribute extends HH::ClassLikeAttribute  = .kind="interface" {}
type HH::EnumClassAttribute extends HH::ClassLikeAttribute  = .kind="interface" {}
type HH::FileAttribute = .kind="interface" {}
type HH::FunctionAttribute = .kind="interface" {}
type HH::InstancePropertyAttribute extends HH::PropertyAttribute  = .kind="interface" {}
type HH::LambdaAttribute = .kind="interface" {}
type HH::MethodAttribute = .kind="interface" {}
type HH::ModuleAttribute = .kind="interface" {}
type HH::ParameterAttribute = .kind="interface" {}
type HH::PropertyAttribute = .kind="interface" {}
type HH::StaticPropertyAttribute extends HH::PropertyAttribute  = .kind="interface" {}
type HH::TypeAliasAttribute = .kind="interface" {}
type HH::TypeConstantAttribute = .kind="interface" {}
type HH::TypeParameterAttribute = .kind="interface" {}
// decls from ./builtins_fb.hhi
// decls from ./classes.hhi
type Generator extends HH::KeyedIterator  = .kind="class" .final {}
type HH::AsyncFunctionWaitHandle extends HH::ResumableWaitHandle  = .kind="class" .final {}
type HH::AsyncGenerator extends HH::AsyncKeyedIterator  = .kind="class" .final {}
type HH::AsyncGeneratorWaitHandle extends HH::ResumableWaitHandle  = .kind="class" .final {}
type HH::AwaitAllWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .final {}
// *** type HH::Awaitable = .kind="class" .abstract {}
type HH::ConcurrentWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .final {}
type HH::ConditionWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .final {}
type HH::ExternalThreadEventWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .final {}
type HH::RescheduleWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .final {}
type HH::ResumableWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .abstract {}
type HH::SleepWaitHandle extends HH::WaitableWaitHandle  = .kind="class" .final {}
// *** type HH::StaticWaitHandle extends HH::Awaitable  = .kind="class" .final {}
// *** type HH::WaitableWaitHandle extends HH::Awaitable  = .kind="class" .abstract {}
type stdClass = .kind="class" .final {}
// decls from ./classname.hhi
// ALIAS: type HH::classname should be defined manually above
// ALIAS: type HH::typename should be defined manually above
// decls from ./coeffect/capabilities.hhi
type HH::Capabilities::AccessGlobals extends HH::Capabilities::ReadGlobals  = .kind="interface" {}
type HH::Capabilities::IO = .kind="interface" {}
type HH::Capabilities::ImplicitPolicy = .kind="interface" {}
type HH::Capabilities::ImplicitPolicyLocal extends HH::Capabilities::ImplicitPolicyShallow  = .kind="interface" {}
type HH::Capabilities::ImplicitPolicyOf extends HH::Capabilities::ImplicitPolicy  = .kind="interface" {}
type HH::Capabilities::ImplicitPolicyOfLocal extends HH::Capabilities::ImplicitPolicyLocal, HH::Capabilities::ImplicitPolicyOfShallow  = .kind="interface" {}
type HH::Capabilities::ImplicitPolicyOfShallow extends HH::Capabilities::ImplicitPolicyOf, HH::Capabilities::ImplicitPolicyShallow  = .kind="interface" {}
type HH::Capabilities::ImplicitPolicyShallow extends HH::Capabilities::ImplicitPolicy  = .kind="interface" {}
type HH::Capabilities::ReadGlobals = .kind="interface" {}
type HH::Capabilities::Rx = .kind="interface" {}
type HH::Capabilities::RxLocal extends HH::Capabilities::RxShallow  = .kind="interface" {}
type HH::Capabilities::RxShallow extends HH::Capabilities::Rx  = .kind="interface" {}
type HH::Capabilities::System = .kind="interface" {}
type HH::Capabilities::SystemLocal extends HH::Capabilities::SystemShallow  = .kind="interface" {}
type HH::Capabilities::SystemShallow extends HH::Capabilities::System  = .kind="interface" {}
type HH::Capabilities::WriteProperty = .kind="interface" {}
// decls from ./coeffect/contexts.hhi
// ALIAS: type HH::Contexts::defaults should be defined manually above
// ALIAS: type HH::Contexts::globals should be defined manually above
// ALIAS: type HH::Contexts::leak_safe should be defined manually above
// ALIAS: type HH::Contexts::leak_safe_local should be defined manually above
// ALIAS: type HH::Contexts::leak_safe_shallow should be defined manually above
// ALIAS: type HH::Contexts::read_globals should be defined manually above
// ALIAS: type HH::Contexts::rx should be defined manually above
// ALIAS: type HH::Contexts::rx_local should be defined manually above
// ALIAS: type HH::Contexts::rx_shallow should be defined manually above
// ALIAS: type HH::Contexts::write_props should be defined manually above
// ALIAS: type HH::Contexts::zoned should be defined manually above
// ALIAS: type HH::Contexts::zoned_local should be defined manually above
// ALIAS: type HH::Contexts::zoned_shallow should be defined manually above
// ALIAS: type HH::Contexts::zoned_with should be defined manually above
// decls from ./coeffect/unsafe_contexts.hhi
// ALIAS: type HH::Contexts::Unsafe::defaults should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::globals should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::leak_safe should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::leak_safe_local should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::leak_safe_shallow should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::read_globals should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::rx should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::rx_local should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::rx_shallow should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::write_props should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::zoned should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::zoned_local should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::zoned_shallow should be defined manually above
// ALIAS: type HH::Contexts::Unsafe::zoned_with should be defined manually above
// decls from ./collections/ImmMap.hhi
type HH::ImmMap extends ConstMap  = .kind="class" .final {}
// decls from ./collections/ImmSet.hhi
type HH::ImmSet extends ConstSet  = .kind="class" .final {}
// decls from ./collections/ImmVector.hhi
type HH::ImmVector extends ConstVector  = .kind="class" .final {}
// decls from ./collections/Map.hhi
type HH::Map extends MutableMap  = .kind="class" .final {}
type MapIterator extends HH::KeyedIterator  = .kind="class" {}
// decls from ./collections/Pair.hhi
type HH::Pair extends ConstVector  = .kind="class" .final {}
type PairIterator extends HH::KeyedIterator  = .kind="class" {}
// decls from ./collections/Set.hhi
type HH::Set extends MutableSet  = .kind="class" .final {}
type SetIterator extends HH::KeyedIterator  = .kind="class" {}
// decls from ./collections/Vector.hhi
type HH::Vector extends MutableVector  = .kind="class" .final {}
type VectorIterator extends HH::KeyedIterator  = .kind="class" {}
// decls from ./collections/interfaces.hhi
type ConstCollection extends Countable, IPureStringishObject  = .kind="interface" {}
type ConstIndexAccess = .kind="interface" {}
type ConstMap extends ConstCollection, ConstMapAccess, HH::KeyedContainer, HH::KeyedIterable  = .kind="interface" {}
type ConstMapAccess extends ConstIndexAccess, ConstSetAccess  = .kind="interface" {}
type ConstSet extends ConstCollection, ConstSetAccess, HH::KeyedContainer, HH::KeyedIterable  = .kind="interface" {}
type ConstSetAccess = .kind="interface" {}
type ConstVector extends ConstCollection, ConstIndexAccess, HH::KeyedContainer, HH::KeyedIterable  = .kind="interface" {}
type HH::Collection extends ConstCollection, OutputCollection  = .kind="interface" {}
type IndexAccess extends ConstIndexAccess  = .kind="interface" {}
type MapAccess extends ConstMapAccess, IndexAccess, SetAccess  = .kind="interface" {}
type MutableMap extends ConstMap, HH::Collection, MapAccess  = .kind="interface" {}
type MutableSet extends ConstSet, HH::Collection, SetAccess  = .kind="interface" {}
type MutableVector extends ConstVector, HH::Collection, IndexAccess  = .kind="interface" {}
type OutputCollection = .kind="interface" {}
type SetAccess extends ConstSetAccess  = .kind="interface" {}
// decls from ./constants.hhi
// decls from ./container_functions.hhi
// decls from ./dyn_func_pointers.hhi
// decls from ./exceptions.hhi
type AccessPropertyOnNonObjectException extends LogicException  = .kind="class" .final {}
type ArgumentCountError extends Error  = .kind="class" {}
type ArithmeticError extends Error  = .kind="class" {}
type AssertionError extends Error  = .kind="class" {}
type BadFunctionCallException extends LogicException  = .kind="class" {}
type BadMethodCallException extends BadFunctionCallException  = .kind="class" {}
type CoeffectViolationException extends LogicException  = .kind="class" .final {}
type DivisionByZeroError extends Error  = .kind="class" {}
type DivisionByZeroException extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type DomainException extends LogicException  = .kind="class" {}
type Error extends Throwable  = .kind="class" {}
type ErrorException extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type Exception extends Throwable  = .kind="class" {}
type ExceptionWithPureGetMessage extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type HH::InvariantException extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type IExceptionWithPureGetMessage = .kind="interface" {}
type InvalidArgumentException extends LogicException  = .kind="class" {}
type InvalidCallbackArgumentException extends LogicException  = .kind="class" .final {}
type InvalidForeachArgumentException extends LogicException  = .kind="class" .final {}
type LengthException extends LogicException  = .kind="class" {}
type LogicException extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type ModuleBoundaryViolationException extends LogicException  = .kind="class" .final {}
type OutOfBoundsException extends RuntimeException  = .kind="class" {}
type OutOfRangeException extends LogicException  = .kind="class" {}
type OverflowException extends RuntimeException  = .kind="class" {}
type ParseError extends Error  = .kind="class" {}
type RangeException extends RuntimeException  = .kind="class" {}
type ReadonlyViolationException extends LogicException  = .kind="class" .final {}
type RuntimeException extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type Throwable = .kind="interface" {}
type TypeAssertionException extends RuntimeException  = .kind="class" .final {}
type TypeError extends Error  = .kind="class" {}
type TypecastException extends LogicException  = .kind="class" .final {}
type UndefinedPropertyException extends LogicException  = .kind="class" .final {}
type UndefinedVariableException extends LogicException  = .kind="class" .final {}
type UnderflowException extends RuntimeException  = .kind="class" {}
type UnexpectedValueException extends RuntimeException  = .kind="class" {}
// decls from ./experimental_parser_utils.hhi
// ALIAS: type HH::ExperimentalParserUtils::ClassBodyNode should be defined manually above
// ALIAS: type HH::ExperimentalParserUtils::EnumBodyNode should be defined manually above
// ALIAS: type HH::ExperimentalParserUtils::FunctionNode should be defined manually above
// ALIAS: type HH::ExperimentalParserUtils::MethodParametersNode should be defined manually above
// ALIAS: type HH::ExperimentalParserUtils::ShapeNode should be defined manually above
// decls from ./ext_decl.hhi
// ALIAS: type HH::ClassKind should be defined manually above
// ALIAS: type HH::ExtDeclAttribute should be defined manually above
// ALIAS: type HH::ExtDeclClass should be defined manually above
// ALIAS: type HH::ExtDeclClassConst should be defined manually above
// ALIAS: type HH::ExtDeclEnumType should be defined manually above
// ALIAS: type HH::ExtDeclFile should be defined manually above
// ALIAS: type HH::ExtDeclFileConst should be defined manually above
// ALIAS: type HH::ExtDeclFileFunc should be defined manually above
// ALIAS: type HH::ExtDeclMethod should be defined manually above
// ALIAS: type HH::ExtDeclMethodParam should be defined manually above
// ALIAS: type HH::ExtDeclModule should be defined manually above
// ALIAS: type HH::ExtDeclProp should be defined manually above
// ALIAS: type HH::ExtDeclSignature should be defined manually above
// ALIAS: type HH::ExtDeclTParam should be defined manually above
// ALIAS: type HH::ExtDeclTParam_ should be defined manually above
// ALIAS: type HH::ExtDeclTypeConst should be defined manually above
// ALIAS: type HH::ExtDeclTypeConstraint should be defined manually above
// ALIAS: type HH::ExtDeclTypeStructure should be defined manually above
// ALIAS: type HH::ExtDeclTypeStructureKind should be defined manually above
// ALIAS: type HH::ExtDeclTypeStructureSubType should be defined manually above
// ALIAS: type HH::ExtDeclTypeStructure_ should be defined manually above
// ALIAS: type HH::ExtDeclTypedef should be defined manually above
type HH::FileDecls = .kind="class" .final {}
// ALIAS: type HH::Reified should be defined manually above
// ALIAS: type HH::TypeConstraintKind should be defined manually above
// ALIAS: type HH::TypeExpr should be defined manually above
// ALIAS: type HH::TypedefVisibility should be defined manually above
// ALIAS: type HH::Variance should be defined manually above
// ALIAS: type HH::Visibility should be defined manually above
// decls from ./ext_facts.hhi
// ALIAS: type HH::Facts::DeriveFilters should be defined manually above
type HH::Facts::DeriveKind extends HH::BuiltinEnum {}
type HH::Facts::SymbolKind extends HH::BuiltinEnum {}
// ALIAS: type HH::Facts::TypeAttributeFilter should be defined manually above
type HH::Facts::TypeFlag extends HH::BuiltinEnum {}
type HH::Facts::TypeKind extends HH::BuiltinEnum {}
// decls from ./ext_rqtrace.hhi
// decls from ./ext_sodium.hhi
type SodiumException extends Exception  = .kind="class" .final {}
// decls from ./ext_watchman.hhi
// ALIAS: type HH::WatchmanResult should be defined manually above
// decls from ./func_pointers.hhi
// decls from ./functions.hhi
// ALIAS: type HH::ParseTree should be defined manually above
// decls from ./get_proxygen_headers.hhi
// decls from ./hackarray.hhi
type HH::AnyArray extends HH::KeyedContainer, XHPChild  = .kind="class" .abstract {}
// *** type HH::dict extends HH::AnyArray  = .kind="class" .abstract .final {}
// *** type HH::keyset extends HH::AnyArray  = .kind="class" .abstract .final {}
// *** type HH::vec extends HH::AnyArray  = .kind="class" .abstract .final {}
// decls from ./hsl/ext_hsl_io_private.hhi
// decls from ./hsl/ext_hsl_locale.hhi
type HH::Lib::Locale::InvalidLocaleException extends Exception  = .kind="class" .final {}
type HH::Lib::_Private::_Locale::Locale = .kind="class" .final {}
// decls from ./hsl/ext_hsl_os.hhi
// ALIAS: type HH::Lib::OS::FileDescriptor should be defined manually above
// decls from ./hsl/ext_hsl_os_fds.hhi
type HH::Lib::_Private::_OS::ErrnoException extends Exception  = .kind="class" .final {}
// ALIAS: type HH::Lib::_Private::_OS::in_port_t should be defined manually above
// ALIAS: type HH::Lib::_Private::_OS::sa_family_t should be defined manually above
type HH::Lib::_Private::_OS::sockaddr = .kind="class" {}
type HH::Lib::_Private::_OS::sockaddr_in extends HH::Lib::_Private::_OS::sockaddr  = .kind="class" .final {}
type HH::Lib::_Private::_OS::sockaddr_in6 extends HH::Lib::_Private::_OS::sockaddr  = .kind="class" .final {}
type HH::Lib::_Private::_OS::sockaddr_un extends HH::Lib::_Private::_OS::sockaddr  = .kind="class" .abstract {}
type HH::Lib::_Private::_OS::sockaddr_un_pathname extends HH::Lib::_Private::_OS::sockaddr_un  = .kind="class" .final {}
type HH::Lib::_Private::_OS::sockaddr_un_unnamed extends HH::Lib::_Private::_OS::sockaddr_un  = .kind="class" .final {}
// ALIAS: type HH::Lib::_Private::_OS::uint32_t should be defined manually above
// decls from ./hsl/ext_hsl_os_subprocesses.hhi
// ALIAS: type HH::Lib::_Private::_OS::ForkAndExecveOptions should be defined manually above
// decls from ./hsl/ext_hsl_str.hhi
// decls from ./hsl/ext_random.hhi
// decls from ./hsl/ext_regex.hhi
// ALIAS: type HH::Lib::Regex::Match should be defined manually above
// ALIAS: type HH::Lib::Regex::Pattern should be defined manually above
// decls from ./hsl/ext_time.hhi
// decls from ./idx.hhi
// decls from ./imagick/Imagick.hhi
type Imagick extends Countable, HH::Iterator, HH::Traversable  = .kind="class" {}
// decls from ./imagick/ImagickDraw.hhi
type ImagickDraw = .kind="class" {}
// decls from ./imagick/ImagickException.hhi
type ImagickException extends RuntimeException, StringishObject  = .kind="class" {}
// decls from ./imagick/ImagickPixel.hhi
type ImagickPixel = .kind="class" {}
// decls from ./imagick/ImagickPixelIterator.hhi
type ImagickPixelIterator extends HH::Iterator, HH::KeyedTraversable  = .kind="class" {}
// decls from ./implicit_context.hhi
type HH::ImplicitContext = .kind="class" .abstract {}
type HH::MemoizeOption extends HH::BuiltinEnumClass {}
type HH::State extends HH::BuiltinEnum {}
// decls from ./interfaces.hhi
type ArrayAccess = .kind="interface" {}
type Countable = .kind="interface" {}
type HH::AsyncIterator = .kind="interface" {}
type HH::AsyncKeyedIterator extends HH::AsyncIterator  = .kind="interface" {}
type HH::Container extends HH::Traversable  = .kind="interface" {}
type HH::IMemoizeParam = .kind="interface" {}
type HH::Iterable extends IteratorAggregate  = .kind="interface" {}
type HH::Iterator extends HH::Traversable  = .kind="interface" {}
type HH::KeyedContainer extends HH::Container, HH::KeyedTraversable  = .kind="interface" {}
type HH::KeyedIterable extends HH::Iterable, HH::KeyedTraversable  = .kind="interface" {}
type HH::KeyedIterator extends HH::Iterator, HH::KeyedTraversable  = .kind="interface" {}
type HH::KeyedTraversable extends HH::Traversable  = .kind="interface" {}
type HH::Traversable = .kind="interface" {}
type HH::UNSAFESingletonMemoizeParam extends HH::IMemoizeParam  = .kind="interface" {}
type IAsyncDisposable = .kind="interface" {}
type IDisposable = .kind="interface" {}
type ILeakSafeStringishObject extends IZonedStringishObject  = .kind="interface" {}
type IPureStringishObject extends ILeakSafeStringishObject  = .kind="interface" {}
type IZonedStringishObject extends StringishObject  = .kind="interface" {}
type IteratorAggregate extends HH::Traversable  = .kind="interface" {}
type JsonSerializable = .kind="interface" {}
type OuterIterator extends HH::Iterator  = .kind="interface" {}
type RecursiveIterator extends HH::Iterator  = .kind="interface" {}
type SeekableIterator extends HH::Iterator  = .kind="interface" {}
type Serializable = .kind="interface" {}
type Stringish extends XHPChild  = .kind="interface" {}
type StringishObject extends Stringish  = .kind="interface" {}
type XHPChild = .kind="interface" {}
// decls from ./modules.hhi
// decls from ./printf.hhi
type PlainSprintf = .kind="interface" {}
type SprintfQuote = .kind="interface" {}
// decls from ./pseudofunctions.hhi
// decls from ./reflection.hhi
type Reflection = .kind="class" {}
type ReflectionClass extends Reflector  = .kind="class" {}
type ReflectionException extends Exception, ExceptionWithPureGetMessageTrait  = .kind="class" {}
type ReflectionExtension extends Reflector  = .kind="class" {}
type ReflectionFile extends Reflector  = .kind="class" {}
type ReflectionFunction extends ReflectionFunctionAbstract, Reflector  = .kind="class" {}
type ReflectionFunctionAbstract extends Reflector  = .kind="class" .abstract {}
type ReflectionMethod extends ReflectionFunctionAbstract, Reflector  = .kind="class" {}
type ReflectionModule extends Reflector  = .kind="class" {}
type ReflectionObject extends ReflectionClass  = .kind="class" {}
type ReflectionParameter extends Reflector  = .kind="class" {}
type ReflectionProperty extends Reflector  = .kind="class" {}
type ReflectionType extends IPureStringishObject  = .kind="class" {}
type ReflectionTypeAlias extends Reflector  = .kind="class" {}
type ReflectionTypeConstant extends Reflector  = .kind="class" {}
type Reflector extends IPureStringishObject  = .kind="interface" {}
// decls from ./reified_generics.hhi
// decls from ./soundness.hhi
// ALIAS: type HH::FIXME::MISSING_PARAM_TYPE should be defined manually above
// ALIAS: type HH::FIXME::MISSING_PROP_TYPE should be defined manually above
// ALIAS: type HH::FIXME::MISSING_RETURN_TYPE should be defined manually above
// ALIAS: type HH::FIXME::POISON_MARKER should be defined manually above
// decls from ./spl/ArrayIterator.hhi
type ArrayIterator extends HH::KeyedIterator, HH::KeyedTraversable  = .kind="class" {}
// decls from ./spl/EmptyIterator.hhi
type EmptyIterator extends HH::Iterator  = .kind="class" .final {}
// decls from ./spl/FilesystemIterator.hhi
type FilesystemIterator extends DirectoryIterator  = .kind="class" {}
// decls from ./spl/FilterIterator.hhi
type FilterIterator extends IteratorIterator  = .kind="class" .abstract {}
// decls from ./spl/IteratorIterator.hhi
type IteratorIterator extends OuterIterator  = .kind="class" {}
// decls from ./spl/RecursiveDirectoryIterator.hhi
type RecursiveDirectoryIterator extends FilesystemIterator, RecursiveIterator  = .kind="class" {}
// decls from ./spl/RecursiveFilterIterator.hhi
type RecursiveFilterIterator extends FilterIterator, OuterIterator, RecursiveIterator  = .kind="class" .abstract {}
// decls from ./spl/RecursiveIteratorIterator.hhi
type RecursiveIteratorIterator extends OuterIterator  = .kind="class" {}
// decls from ./spl/RecursiveRegexIterator.hhi
type RecursiveRegexIterator extends RecursiveIterator, RegexIterator  = .kind="class" {}
// decls from ./spl/RegexIterator.hhi
type RegexIterator extends FilterIterator  = .kind="class" {}
// decls from ./spl/SplHeap.hhi
type SplHeap extends Countable, HH::Iterator, HH::Traversable  = .kind="class" .abstract {}
// decls from ./spl/SplMaxHeap.hhi
type SplMaxHeap extends SplHeap  = .kind="class" {}
// decls from ./spl/SplMinHeap.hhi
type SplMinHeap extends SplHeap  = .kind="class" {}
// decls from ./stdlib/builtins_apache.hhi
// decls from ./stdlib/builtins_apc.hhi
// decls from ./stdlib/builtins_apd.hhi
// decls from ./stdlib/builtins_array.hhi
// decls from ./stdlib/builtins_asio.hhi
// decls from ./stdlib/builtins_asio_utils.hhi
type HH::Asio::ResultOrExceptionWrapper = .kind="interface" {}
type HH::Asio::WrappedException extends HH::Asio::ResultOrExceptionWrapper  = .kind="class" .final {}
type HH::Asio::WrappedResult extends HH::Asio::ResultOrExceptionWrapper  = .kind="class" .final {}
// decls from ./stdlib/builtins_async_mysql.hhi
type AsyncMysqlClient = .kind="class" {}
type AsyncMysqlClientStats = .kind="class" {}
type AsyncMysqlConnectException extends AsyncMysqlException  = .kind="class" {}
type AsyncMysqlConnectResult extends AsyncMysqlResult  = .kind="class" {}
type AsyncMysqlConnection = .kind="class" {}
type AsyncMysqlConnectionOptions = .kind="class" {}
type AsyncMysqlConnectionPool = .kind="class" {}
type AsyncMysqlErrorResult extends AsyncMysqlResult  = .kind="class" {}
type AsyncMysqlException extends Exception  = .kind="class" {}
type AsyncMysqlQueryErrorResult extends AsyncMysqlErrorResult  = .kind="class" {}
type AsyncMysqlQueryException extends AsyncMysqlException  = .kind="class" {}
type AsyncMysqlQueryResult extends AsyncMysqlResult  = .kind="class" {}
type AsyncMysqlResult = .kind="class" .abstract {}
type AsyncMysqlRow extends MysqlRow  = .kind="class" {}
type AsyncMysqlRowBlock extends Countable, HH::KeyedTraversable  = .kind="class" {}
type HH::Lib::SQL::ListFormat = .kind="interface" {}
type HH::Lib::SQL::Query = .kind="class" .final {}
type HH::Lib::SQL::QueryFormat extends HH::Lib::SQL::ScalarFormat  = .kind="interface" {}
// ALIAS: type HH::Lib::SQL::QueryFormatString should be defined manually above
type HH::Lib::SQL::ScalarFormat = .kind="interface" {}
type HH::SQLFormatter extends HH::SQLScalarFormatter  = .kind="interface" {}
type HH::SQLListFormatter = .kind="interface" {}
type HH::SQLScalarFormatter = .kind="interface" {}
type MySSLContextProvider = .kind="class" {}
type MysqlRow extends Countable, HH::KeyedTraversable, IteratorAggregate  = .kind="interface" {}
// decls from ./stdlib/builtins_bcmath.hhi
// decls from ./stdlib/builtins_bzip2.hhi
// decls from ./stdlib/builtins_class.hhi
// decls from ./stdlib/builtins_closure.hhi
type Closure = .kind="class" {}
// decls from ./stdlib/builtins_constant.hhi
// decls from ./stdlib/builtins_continuation.hhi
// decls from ./stdlib/builtins_ctype.hhi
// decls from ./stdlib/builtins_curl.hhi
type CURLFile = .kind="class" {}
// decls from ./stdlib/builtins_datetime.hhi
type DateInterval = .kind="class" {}
type DatePeriod extends HH::Iterator  = .kind="class" {}
type DateTime extends DateTimeInterface  = .kind="class" {}
// ALIAS: type DateTimeErrors should be defined manually above
type DateTimeImmutable extends DateTimeInterface  = .kind="class" {}
type DateTimeInterface = .kind="interface" {}
type DateTimeZone = .kind="class" {}
// decls from ./stdlib/builtins_debugger.hhi
// decls from ./stdlib/builtins_dom.hhi
type DOMAttr extends DOMNode  = .kind="class" {}
type DOMCdataSection extends DOMText  = .kind="class" {}
type DOMCharacterData extends DOMNode  = .kind="class" .abstract {}
type DOMComment extends DOMCharacterData  = .kind="class" {}
type DOMDocument extends DOMNode  = .kind="class" {}
type DOMDocumentFragment extends DOMNode  = .kind="class" {}
type DOMDocumentType extends DOMNode  = .kind="class" {}
type DOMElement extends DOMNode  = .kind="class" {}
type DOMImplementation = .kind="class" {}
type DOMNamedNodeMap extends HH::KeyedTraversable  = .kind="class" {}
type DOMNode = .kind="class" {}
type DOMNodeList extends IteratorAggregate  = .kind="class" {}
type DOMText extends DOMCharacterData  = .kind="class" {}
type DOMXPath = .kind="class" {}
// decls from ./stdlib/builtins_error.hhi
// decls from ./stdlib/builtins_exit.hhi
// decls from ./stdlib/builtins_file.hhi
// decls from ./stdlib/builtins_filter.hhi
// decls from ./stdlib/builtins_finfo.hhi
type finfo = .kind="class" {}
// decls from ./stdlib/builtins_function.hhi
// decls from ./stdlib/builtins_functioncredential.hhi
type FunctionCredential = .kind="class" .final {}
// decls from ./stdlib/builtins_gettext.hhi
// decls from ./stdlib/builtins_globals.hhi
// decls from ./stdlib/builtins_globals_pseudofunctions.hhi
// decls from ./stdlib/builtins_gmp.hhi
// decls from ./stdlib/builtins_hash.hhi
// decls from ./stdlib/builtins_iconv.hhi
// decls from ./stdlib/builtins_icu.hhi
// decls from ./stdlib/builtins_icu_uchar.hhi
type IntlChar = .kind="class" {}
// decls from ./stdlib/builtins_icu_ucnv.hhi
type UConverter = .kind="class" {}
// decls from ./stdlib/builtins_icu_ucsdet.hhi
type EncodingDetector = .kind="class" {}
type EncodingMatch = .kind="class" {}
// decls from ./stdlib/builtins_icu_uspoof.hhi
type SpoofChecker = .kind="class" {}
// decls from ./stdlib/builtins_image.hhi
// decls from ./stdlib/builtins_imap.hhi
// decls from ./stdlib/builtins_intervaltimer.hhi
type IntervalTimer = .kind="class" {}
// decls from ./stdlib/builtins_intl.hhi
type Collator = .kind="class" {}
type IntlBreakIterator extends HH::KeyedTraversable  = .kind="class" {}
type IntlCalendar = .kind="class" {}
type IntlCodePointBreakIterator extends IntlBreakIterator  = .kind="class" {}
type IntlDateFormatter = .kind="class" {}
type IntlGregorianCalendar extends IntlCalendar  = .kind="class" {}
type IntlIterator extends HH::KeyedIterator  = .kind="class" {}
type IntlPartsIterator extends IntlIterator  = .kind="class" {}
type IntlRuleBasedBreakIterator extends IntlBreakIterator  = .kind="class" {}
type IntlTimeZone = .kind="class" {}
type Locale = .kind="class" {}
type MessageFormatter = .kind="class" {}
type Normalizer = .kind="class" {}
type ResourceBundle extends HH::Traversable  = .kind="class" {}
// decls from ./stdlib/builtins_ipc.hhi
// decls from ./stdlib/builtins_json.hhi
// decls from ./stdlib/builtins_ldap.hhi
// decls from ./stdlib/builtins_lz4.hhi
// decls from ./stdlib/builtins_magick.hhi
// decls from ./stdlib/builtins_mailparse.hhi
// decls from ./stdlib/builtins_math.hhi
// decls from ./stdlib/builtins_mb.hhi
// decls from ./stdlib/builtins_mcrouter.hhi
type MCRouter = .kind="class" {}
type MCRouterException extends Exception  = .kind="class" {}
type MCRouterOptionException extends Exception  = .kind="class" {}
// decls from ./stdlib/builtins_mcrypt.hhi
// decls from ./stdlib/builtins_memcache.hhi
type Memcache = .kind="class" {}
// decls from ./stdlib/builtins_memcached.hhi
type Memcached = .kind="class" {}
// decls from ./stdlib/builtins_misc.hhi
// decls from ./stdlib/builtins_mysql.hhi
// decls from ./stdlib/builtins_network.hhi
// decls from ./stdlib/builtins_openssl.hhi
// decls from ./stdlib/builtins_options.hhi
// decls from ./stdlib/builtins_output.hhi
// decls from ./stdlib/builtins_password.hhi
// decls from ./stdlib/builtins_pdo.hhi
type PDO = .kind="class" {}
type PDOException extends RuntimeException  = .kind="class" {}
type PDOStatement = .kind="class" {}
// decls from ./stdlib/builtins_posix.hhi
// decls from ./stdlib/builtins_preg.hhi
// decls from ./stdlib/builtins_process.hhi
// decls from ./stdlib/builtins_prof.hhi
// ALIAS: type HH::ObjprofObjectStats should be defined manually above
// ALIAS: type HH::ObjprofPathsStats should be defined manually above
// ALIAS: type HH::ObjprofStringStats should be defined manually above
// decls from ./stdlib/builtins_random.hhi
// decls from ./stdlib/builtins_readline.hhi
// decls from ./stdlib/builtins_readonly.hhi
type HH::Readonly::Shapes = .kind="class" .abstract .final {}
// decls from ./stdlib/builtins_server.hhi
// decls from ./stdlib/builtins_simplexml.hhi
type LibXMLError = .kind="class" {}
type SimpleXMLElement = .kind="class" {}
type SimpleXMLElementIterator = .kind="class" {}
// decls from ./stdlib/builtins_snappy.hhi
// decls from ./stdlib/builtins_soap.hhi
type SoapClient = .kind="class" {}
type SoapFault extends Exception  = .kind="class" {}
type SoapHeader = .kind="class" {}
type SoapParam = .kind="class" {}
type SoapServer = .kind="class" {}
type SoapVar = .kind="class" {}
// decls from ./stdlib/builtins_socket.hhi
// decls from ./stdlib/builtins_spl.hhi
type DirectoryIterator extends SeekableIterator, SplFileInfo  = .kind="class" {}
type GlobIterator extends Countable, FilesystemIterator  = .kind="class" {}
type InfiniteIterator extends IteratorIterator  = .kind="class" {}
type NoRewindIterator extends IteratorIterator  = .kind="class" {}
type SplDoublyLinkedList extends ArrayAccess, Countable, HH::Iterator  = .kind="class" {}
type SplFileInfo = .kind="class" {}
type SplFileObject extends RecursiveIterator, SeekableIterator, SplFileInfo  = .kind="class" {}
type SplObserver = .kind="interface" {}
type SplPriorityQueue extends Countable, HH::Iterator  = .kind="class" {}
type SplQueue extends SplDoublyLinkedList  = .kind="class" {}
type SplStack extends SplDoublyLinkedList  = .kind="class" {}
type SplSubject = .kind="interface" {}
type SplTempFileObject extends SplFileObject  = .kind="class" {}
// decls from ./stdlib/builtins_sqlite3.hhi
type SQLite3 = .kind="class" {}
type SQLite3Result = .kind="class" {}
type SQLite3Stmt = .kind="class" {}
// decls from ./stdlib/builtins_stream.hhi
// decls from ./stdlib/builtins_string.hhi
// decls from ./stdlib/builtins_thread.hhi
// decls from ./stdlib/builtins_thrift.hhi
type ThriftApplicationException extends Exception  = .kind="class" .final {}
// decls from ./stdlib/builtins_transliterator.hhi
type Transliterator = .kind="class" {}
// decls from ./stdlib/builtins_url.hhi
// decls from ./stdlib/builtins_variable.hhi
// decls from ./stdlib/builtins_xenon.hhi
// ALIAS: type HH::XenonSample should be defined manually above
// decls from ./stdlib/builtins_xml.hhi
// decls from ./stdlib/builtins_xmlwriter.hhi
type XMLWriter = .kind="class" {}
// decls from ./stdlib/builtins_xslt.hhi
type XSLTProcessor = .kind="class" {}
// decls from ./stdlib/builtins_zip.hhi
type ZipArchive = .kind="class" {}
// decls from ./stdlib/builtins_zlib.hhi
// decls from ./string_coercions.hhi
// decls from ./supportdynamic.hhi
// ALIAS: type HH::supportdyn should be defined manually above
// decls from ./traits.hhi
// decls from ./typenames.hhi
// ALIAS: type HH::FormatString should be defined manually above
// ALIAS: type HH::FunctionRef should be defined manually above
// decls from ./typestructure.hhi
// ALIAS: type HH::TypeStructure should be defined manually above
type HH::TypeStructureKind extends HH::BuiltinEnum {}
// decls from ./weakref.hhi
type WeakRef = .kind="class" .final {}
